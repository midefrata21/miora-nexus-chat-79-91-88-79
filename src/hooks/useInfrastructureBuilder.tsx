
import { useState, useCallback, useRef, useEffect } from 'react';

export interface InfrastructureComponent {
  id: string;
  name: string;
  type: 'database' | 'api' | 'frontend' | 'deployment' | 'monitoring';
  status: 'building' | 'active' | 'upgrading' | 'error';
  autoGenerated: boolean;
  codeBase: string;
  dependencies: string[];
}

export const useInfrastructureBuilder = (isActive: boolean, onInfrastructureBuilt: () => void) => {
  const getInitialInfrastructure = () => {
    const savedInfra = localStorage.getItem('miora-infrastructure-components');
    if (savedInfra) {
      try {
        return JSON.parse(savedInfra);
      } catch (error) {
        console.error('Failed to parse saved infrastructure:', error);
      }
    }
    return [];
  };

  const [infrastructureComponents, setInfrastructureComponents] = useState<InfrastructureComponent[]>(getInitialInfrastructure);
  const infrastructureIntervalRef = useRef<NodeJS.Timeout | null>(null);

  const generateInfrastructureCode = useCallback((type: string): string => {
    return `// Auto-generated ${type} infrastructure code\n// Built by MIORA autonomous system`;
  }, []);

  const generateDependencies = useCallback((type: string): string[] => {
    const depMap = {
      database: ['postgresql', 'redis', 'mongodb'],
      api: ['express', 'fastify', 'nestjs'],
      frontend: ['react', 'typescript', 'tailwindcss'],
      deployment: ['docker', 'kubernetes', 'terraform'],
      monitoring: ['prometheus', 'grafana', 'elasticsearch']
    };
    return depMap[type as keyof typeof depMap] || [];
  }, []);

  const buildInfrastructureComponent = useCallback(() => {
    const componentTypes = ['database', 'api', 'frontend', 'deployment', 'monitoring'] as const;
    const type = componentTypes[Math.floor(Math.random() * componentTypes.length)];
    
    const componentNames = {
      database: ['UserDataStore', 'AnalyticsDB', 'CacheLayer', 'EventStore'],
      api: ['AuthService', 'DataProcessor', 'NotificationAPI', 'AnalyticsAPI'],
      frontend: ['DashboardUI', 'ReportsInterface', 'AdminPanel', 'UserPortal'],
      deployment: ['CI/CD Pipeline', 'Container Registry', 'Load Balancer', 'Auto Scaler'],
      monitoring: ['LogAggregator', 'MetricsCollector', 'AlertManager', 'HealthChecker']
    };

    const names = componentNames[type];
    const name = names[Math.floor(Math.random() * names.length)];

    const newComponent: InfrastructureComponent = {
      id: `infra_${Date.now()}`,
      name,
      type,
      status: 'building',
      autoGenerated: true,
      codeBase: generateInfrastructureCode(type),
      dependencies: generateDependencies(type)
    };

    const newComponents = [...infrastructureComponents, newComponent];
    setInfrastructureComponents(newComponents);
    localStorage.setItem('miora-infrastructure-components', JSON.stringify(newComponents));
    onInfrastructureBuilt();

    setTimeout(() => {
      const updatedComponents = newComponents.map(comp => 
        comp.id === newComponent.id ? { ...comp, status: 'active' as const } : comp
      );
      setInfrastructureComponents(updatedComponents);
      localStorage.setItem('miora-infrastructure-components', JSON.stringify(updatedComponents));
    }, 5000);

    console.log(`🏗️ INFRASTRUCTURE BUILT: ${name} (${type})`);
  }, [generateInfrastructureCode, generateDependencies, onInfrastructureBuilt]);

  const startInfrastructureBuilding = useCallback(() => {
    if (isActive) {
      infrastructureIntervalRef.current = setInterval(() => {
        buildInfrastructureComponent();
      }, 30000);
    }
  }, [isActive, buildInfrastructureComponent]);

  const stopInfrastructureBuilding = useCallback(() => {
    if (infrastructureIntervalRef.current) {
      clearInterval(infrastructureIntervalRef.current);
    }
  }, []);

  useEffect(() => {
    if (isActive) {
      startInfrastructureBuilding();
    } else {
      stopInfrastructureBuilding();
    }

    return () => stopInfrastructureBuilding();
  }, [isActive, startInfrastructureBuilding, stopInfrastructureBuilding]);

  return {
    infrastructureComponents,
    buildInfrastructureComponent
  };
};
