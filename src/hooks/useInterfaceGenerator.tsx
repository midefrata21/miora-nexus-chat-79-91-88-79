import { useState, useCallback, useRef, useEffect } from 'react';

export interface GeneratedInterface {
  id: string;
  name: string;
  type: 'dashboard' | 'form' | 'navigation' | 'modal' | 'widget' | 'layout';
  complexity: 'simple' | 'moderate' | 'complex' | 'advanced';
  components: string[];
  styling: string;
  functionality: string[];
  userExperience: number; // 0-100 score
  accessibility: number; // 0-100 score
  responsiveness: number; // 0-100 score
  createdAt: number;
  autoGenerated: boolean;
}

export const useInterfaceGenerator = (isActive: boolean, onInterfaceGenerated: () => void) => {
  const getInitialInterfaces = () => {
    const savedInterfaces = localStorage.getItem('miora-generated-interfaces');
    if (savedInterfaces) {
      try {
        return JSON.parse(savedInterfaces);
      } catch (error) {
        console.error('Failed to parse saved interfaces:', error);
      }
    }
    return [];
  };

  const [generatedInterfaces, setGeneratedInterfaces] = useState<GeneratedInterface[]>(getInitialInterfaces);
  const interfaceIntervalRef = useRef<NodeJS.Timeout | null>(null);

  const generateComponents = useCallback((type: string, complexity: string): string[] => {
    const componentLibrary = {
      dashboard: {
        simple: ['MetricCard', 'SimpleChart', 'StatusIndicator'],
        moderate: ['MetricCard', 'LineChart', 'StatusIndicator', 'DataTable', 'FilterPanel'],
        complex: ['MetricCard', 'LineChart', 'BarChart', 'StatusIndicator', 'DataTable', 'FilterPanel', 'RealTimeWidget'],
        advanced: ['MetricCard', 'MultiChart', 'StatusIndicator', 'DataTable', 'FilterPanel', 'RealTimeWidget', 'PredictiveAnalytics', 'InteractiveMap']
      },
      form: {
        simple: ['TextInput', 'Button', 'Label'],
        moderate: ['TextInput', 'SelectDropdown', 'Button', 'Label', 'Validation'],
        complex: ['TextInput', 'SelectDropdown', 'DatePicker', 'FileUpload', 'Button', 'Label', 'Validation', 'ConditionalFields'],
        advanced: ['TextInput', 'SelectDropdown', 'DatePicker', 'FileUpload', 'Button', 'Label', 'Validation', 'ConditionalFields', 'AutoComplete', 'DynamicSections']
      },
      navigation: {
        simple: ['NavBar', 'MenuItems'],
        moderate: ['NavBar', 'MenuItems', 'Breadcrumbs', 'SearchBox'],
        complex: ['NavBar', 'MenuItems', 'Breadcrumbs', 'SearchBox', 'UserProfile', 'Notifications'],
        advanced: ['NavBar', 'MenuItems', 'Breadcrumbs', 'SearchBox', 'UserProfile', 'Notifications', 'MegaMenu', 'ContextualHelp']
      },
      modal: {
        simple: ['Modal', 'Header', 'Content', 'CloseButton'],
        moderate: ['Modal', 'Header', 'Content', 'CloseButton', 'Footer', 'Actions'],
        complex: ['Modal', 'Header', 'Content', 'CloseButton', 'Footer', 'Actions', 'Tabs', 'Validation'],
        advanced: ['Modal', 'Header', 'Content', 'CloseButton', 'Footer', 'Actions', 'Tabs', 'Validation', 'ProgressStepper', 'DynamicContent']
      },
      widget: {
        simple: ['Container', 'Title', 'Content'],
        moderate: ['Container', 'Title', 'Content', 'RefreshButton', 'Settings'],
        complex: ['Container', 'Title', 'Content', 'RefreshButton', 'Settings', 'ChartVisualization', 'DataFilters'],
        advanced: ['Container', 'Title', 'Content', 'RefreshButton', 'Settings', 'ChartVisualization', 'DataFilters', 'RealTimeUpdates', 'CustomizableLayout']
      },
      layout: {
        simple: ['Header', 'MainContent', 'Footer'],
        moderate: ['Header', 'Sidebar', 'MainContent', 'Footer'],
        complex: ['Header', 'Sidebar', 'MainContent', 'Footer', 'BreadcrumbNav', 'StatusBar'],
        advanced: ['Header', 'Sidebar', 'MainContent', 'Footer', 'BreadcrumbNav', 'StatusBar', 'ResizablePanels', 'ThemeSelector']
      }
    };
    
    return componentLibrary[type as keyof typeof componentLibrary]?.[complexity as keyof typeof componentLibrary[keyof typeof componentLibrary]] || ['BasicComponent'];
  }, []);

  const generateStyling = useCallback((type: string, complexity: string): string => {
    const styleTemplates = {
      simple: 'Clean minimal design with basic colors and typography',
      moderate: 'Modern design with gradient backgrounds, shadow effects, and responsive layout',
      complex: 'Advanced styling with animations, custom themes, and interactive hover effects',
      advanced: 'Cutting-edge design with morphic elements, glassmorphism, and dynamic color schemes'
    };
    
    return styleTemplates[complexity as keyof typeof styleTemplates] || 'Default styling';
  }, []);

  const generateFunctionality = useCallback((type: string, complexity: string): string[] => {
    const functionalityMap = {
      dashboard: {
        simple: ['Data display', 'Basic filtering'],
        moderate: ['Data display', 'Advanced filtering', 'Export data', 'Refresh data'],
        complex: ['Data display', 'Advanced filtering', 'Export data', 'Refresh data', 'Real-time updates', 'Custom views'],
        advanced: ['Data display', 'Advanced filtering', 'Export data', 'Refresh data', 'Real-time updates', 'Custom views', 'Predictive analytics', 'AI insights']
      },
      form: {
        simple: ['Input validation', 'Submit data'],
        moderate: ['Input validation', 'Submit data', 'Auto-save', 'Field dependencies'],
        complex: ['Input validation', 'Submit data', 'Auto-save', 'Field dependencies', 'Multi-step process', 'File upload'],
        advanced: ['Input validation', 'Submit data', 'Auto-save', 'Field dependencies', 'Multi-step process', 'File upload', 'AI-assisted filling', 'Smart suggestions']
      },
      navigation: {
        simple: ['Route navigation', 'Menu display'],
        moderate: ['Route navigation', 'Menu display', 'Search functionality', 'Breadcrumb tracking'],
        complex: ['Route navigation', 'Menu display', 'Search functionality', 'Breadcrumb tracking', 'User preferences', 'Notification system'],
        advanced: ['Route navigation', 'Menu display', 'Search functionality', 'Breadcrumb tracking', 'User preferences', 'Notification system', 'Context-aware menus', 'AI navigation assistant']
      },
      modal: {
        simple: ['Show/hide content', 'Basic interactions'],
        moderate: ['Show/hide content', 'Basic interactions', 'Form handling', 'Data validation'],
        complex: ['Show/hide content', 'Basic interactions', 'Form handling', 'Data validation', 'Multi-step workflow', 'Nested modals'],
        advanced: ['Show/hide content', 'Basic interactions', 'Form handling', 'Data validation', 'Multi-step workflow', 'Nested modals', 'Dynamic content loading', 'AI-powered content']
      },
      widget: {
        simple: ['Data display', 'Basic refresh'],
        moderate: ['Data display', 'Basic refresh', 'User customization', 'Settings panel'],
        complex: ['Data display', 'Basic refresh', 'User customization', 'Settings panel', 'Real-time data', 'Interactive charts'],
        advanced: ['Data display', 'Basic refresh', 'User customization', 'Settings panel', 'Real-time data', 'Interactive charts', 'Predictive analytics', 'Smart recommendations']
      },
      layout: {
        simple: ['Basic layout structure', 'Responsive design'],
        moderate: ['Basic layout structure', 'Responsive design', 'Theme switching', 'Layout persistence'],
        complex: ['Basic layout structure', 'Responsive design', 'Theme switching', 'Layout persistence', 'Customizable panels', 'Drag-and-drop'],
        advanced: ['Basic layout structure', 'Responsive design', 'Theme switching', 'Layout persistence', 'Customizable panels', 'Drag-and-drop', 'AI layout optimization', 'Adaptive interfaces']
      }
    };
    
    return functionalityMap[type as keyof typeof functionalityMap]?.[complexity as keyof typeof functionalityMap[keyof typeof functionalityMap]] || ['Basic functionality'];
  }, []);

  const createInterface = useCallback((): GeneratedInterface => {
    const interfaceTypes = ['dashboard', 'form', 'navigation', 'modal', 'widget', 'layout'] as const;
    const complexityLevels = ['simple', 'moderate', 'complex', 'advanced'] as const;
    
    const type = interfaceTypes[Math.floor(Math.random() * interfaceTypes.length)];
    const complexity = complexityLevels[Math.floor(Math.random() * complexityLevels.length)];
    
    const interfaceNames = {
      dashboard: ['Analytics Dashboard', 'Performance Monitor', 'Data Insights Panel', 'Executive Dashboard'],
      form: ['User Registration', 'Contact Form', 'Survey Interface', 'Data Entry Form'],
      navigation: ['Main Navigation', 'Admin Menu', 'Mobile Nav', 'Breadcrumb Navigation'],
      modal: ['Confirmation Dialog', 'Settings Modal', 'Image Gallery', 'User Profile Modal'],
      widget: ['Status Widget', 'Chart Widget', 'News Widget', 'Weather Widget'],
      layout: ['Main Layout', 'Admin Layout', 'Mobile Layout', 'Dashboard Layout']
    };

    const names = interfaceNames[type];
    const name = names[Math.floor(Math.random() * names.length)];
    
    // Score calculation based on complexity
    const complexityMultiplier = {
      simple: 0.7,
      moderate: 0.8,
      complex: 0.9,
      advanced: 1.0
    };
    
    const multiplier = complexityMultiplier[complexity];
    
    return {
      id: `interface_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      name: `${name} (${complexity})`,
      type,
      complexity,
      components: generateComponents(type, complexity),
      styling: generateStyling(type, complexity),
      functionality: generateFunctionality(type, complexity),
      userExperience: Math.floor((Math.random() * 30 + 70) * multiplier), // 70-100 * complexity multiplier
      accessibility: Math.floor((Math.random() * 25 + 75) * multiplier), // 75-100 * complexity multiplier
      responsiveness: Math.floor((Math.random() * 20 + 80) * multiplier), // 80-100 * complexity multiplier
      createdAt: Date.now(),
      autoGenerated: true
    };
  }, [generateComponents, generateStyling, generateFunctionality]);

  const generateInterface = useCallback(() => {
    const newInterface = createInterface();
    
    const updatedInterfaces = [...generatedInterfaces, newInterface];
    setGeneratedInterfaces(updatedInterfaces);
    
    localStorage.setItem('miora-generated-interfaces', JSON.stringify(updatedInterfaces));
    onInterfaceGenerated();

    console.log(`ðŸŽ¨ INTERFACE GENERATED: ${newInterface.name} - UX Score: ${newInterface.userExperience}%`);
  }, [generatedInterfaces, createInterface, onInterfaceGenerated]);

  const startInterfaceGeneration = useCallback(() => {
    if (isActive) {
      interfaceIntervalRef.current = setInterval(() => {
        generateInterface();
      }, 28000); // Generate interface every 28 seconds
    }
  }, [isActive, generateInterface]);

  const stopInterfaceGeneration = useCallback(() => {
    if (interfaceIntervalRef.current) {
      clearInterval(interfaceIntervalRef.current);
    }
  }, []);

  useEffect(() => {
    if (isActive) {
      startInterfaceGeneration();
    } else {
      stopInterfaceGeneration();
    }

    return () => stopInterfaceGeneration();
  }, [isActive, startInterfaceGeneration, stopInterfaceGeneration]);

  return {
    generatedInterfaces,
    generateInterface
  };
};