
import { useState, useEffect } from 'react';
import { useInfinityLearningSystem } from './useInfinityLearningSystem';
import { useBackgroundLearning } from './useBackgroundLearning';
import { toast } from '@/hooks/use-toast';

interface AutoCodeCommand {
  id: string;
  trigger: string;
  command: string;
  description: string;
  category: string;
  autoGenerated: boolean;
  executionCount: number;
  name: string;
  version: string;
  efficiency: number;
  isPermanent: boolean;
  example: string;
  triggerConditions: string[];
}

interface CommandExecution {
  timestamp: number;
  command: string;
  success: boolean;
  result: string;
}

interface InfrastructureProject {
  id: string;
  name: string;
  description: string;
  category: string;
  status: 'active' | 'development' | 'inactive';
  version: string;
  codeBase: string;
  dependencies: string[];
  endpoints: string[];
}

export const useAutoCodeCore = () => {
  const [autoCodes, setAutoCodes] = useState<AutoCodeCommand[]>([
    {
      id: 'infinity_learning',
      trigger: 'pembelajaran tanpa batas',
      command: '/activate-infinity-learning',
      name: '/activate-infinity-learning',
      description: 'Mengaktifkan sistem pembelajaran tanpa batas MIORA',
      category: 'learning',
      autoGenerated: false,
      executionCount: 0,
      version: '1.0',
      efficiency: 95,
      isPermanent: true,
      example: '/activate-infinity-learning',
      triggerConditions: ['infinity mode', 'unlimited learning']
    },
    {
      id: 'background_processing',
      trigger: 'proses latar belakang',
      command: '/enable-background-processing',
      name: '/enable-background-processing',
      description: 'Mengaktifkan pemrosesan otomatis di latar belakang',
      category: 'system',
      autoGenerated: false,
      executionCount: 0,
      version: '1.0',
      efficiency: 88,
      isPermanent: true,
      example: '/enable-background-processing',
      triggerConditions: ['background mode', 'auto process']
    }
  ]);

  const [commandHistory, setCommandHistory] = useState<CommandExecution[]>([]);
  const [infrastructureProjects] = useState<InfrastructureProject[]>([
    {
      id: 'signalbot',
      name: 'SignalBot Engine',
      description: 'Automated trading signal generation and execution',
      category: 'SignalBot Engine',
      status: 'active',
      version: '2.1',
      codeBase: 'Python/FastAPI',
      dependencies: ['pandas', 'numpy', 'fastapi'],
      endpoints: ['/api/signals', '/api/execute']
    }
  ]);
  const [isCompiling, setIsCompiling] = useState(false);
  const [autoCommandMode, setAutoCommandMode] = useState(false);

  const { activateInfinityMode, isInfinityModeActive } = useInfinityLearningSystem();
  const { startBackgroundLearning, isBackgroundActive } = useBackgroundLearning();

  const detectAndCreateCommand = (input: string, context: string) => {
    const lowerInput = input.toLowerCase();
    
    const matchedCommand = autoCodes.find(code => 
      lowerInput.includes(code.trigger.toLowerCase())
    );

    if (matchedCommand) {
      executeAutoCommand(matchedCommand.id);
      return true;
    }

    if (lowerInput.includes('mode infinity') || lowerInput.includes('∞')) {
      if (!isInfinityModeActive) {
        activateInfinityMode();
        return true;
      }
    }

    return false;
  };

  const createNewAutoCommand = (
    id: string,
    trigger: string,
    command: string,
    description: string,
    category: string
  ) => {
    const newCommand: AutoCodeCommand = {
      id,
      trigger,
      command,
      name: command,
      description,
      category,
      autoGenerated: true,
      executionCount: 0,
      version: '1.0',
      efficiency: 75,
      isPermanent: false,
      example: command,
      triggerConditions: [trigger]
    };

    setAutoCodes(prev => [...prev, newCommand]);
    
    toast({
      title: "🤖 AutoCode Generated",
      description: `New command created: ${command}`,
      duration: 3000,
    });
  };

  const executeAutoCommand = (commandId: string) => {
    const command = autoCodes.find(c => c.id === commandId);
    if (!command) return false;

    setAutoCodes(prev => prev.map(c => 
      c.id === commandId ? { ...c, executionCount: c.executionCount + 1 } : c
    ));

    const execution: CommandExecution = {
      timestamp: Date.now(),
      command: command.name,
      success: true,
      result: `Successfully executed ${command.name}`
    };

    setCommandHistory(prev => [...prev, execution]);

    switch (commandId) {
      case 'infinity_learning':
        if (!isInfinityModeActive) {
          activateInfinityMode();
        }
        break;
      
      case 'background_processing':
        if (!isBackgroundActive) {
          startBackgroundLearning();
        }
        break;
    }

    return true;
  };

  // Additional functions expected by AutoCodeInterface
  const createAutoCommand = (name: string, description: string, category: string, source: string) => {
    createNewAutoCommand(
      `auto_${Date.now()}`,
      name.toLowerCase(),
      name,
      description,
      category
    );
  };

  const createInfrastructureProject = (name: string, description: string) => {
    toast({
      title: "🏗️ Infrastructure Project",
      description: `Created: ${name}`,
      duration: 3000,
    });
  };

  const executeCommand = async (commandName: string, params: any) => {
    setIsCompiling(true);
    
    setTimeout(() => {
      const execution: CommandExecution = {
        timestamp: Date.now(),
        command: commandName,
        success: true,
        result: `Executed ${commandName} with params`
      };
      
      setCommandHistory(prev => [...prev, execution]);
      setIsCompiling(false);
      
      toast({
        title: "✅ Command Executed",
        description: `${commandName} completed successfully`,
        duration: 3000,
      });
    }, 2000);
  };

  const improveCommand = (commandId: string) => {
    toast({
      title: "🔧 Command Improved",
      description: "Command optimization completed",
      duration: 3000,
    });
  };

  const getCommandStats = () => {
    const totalExecutions = commandHistory.length;
    const successfulExecutions = commandHistory.filter(e => e.success).length;
    const averageEfficiency = autoCodes.reduce((acc, cmd) => acc + cmd.efficiency, 0) / autoCodes.length;
    
    return {
      totalExecutions,
      successRate: totalExecutions > 0 ? successfulExecutions / totalExecutions : 1,
      averageEfficiency,
      activeInfrastructure: infrastructureProjects.filter(p => p.status === 'active').length
    };
  };

  return {
    autoCodes,
    autoCommands: autoCodes, // Alias for backward compatibility
    commandHistory,
    infrastructureProjects,
    isCompiling,
    autoCommandMode,
    setAutoCommandMode,
    detectAndCreateCommand,
    executeAutoCommand,
    createNewAutoCommand,
    createAutoCommand,
    createInfrastructureProject,
    executeCommand,
    improveCommand,
    getCommandStats
  };
};
