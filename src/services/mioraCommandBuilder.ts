import { GeneratedCode } from './aiCodeGenerator';

export interface MioraCommand {
  id: string;
  name: string;
  description: string;
  category: 'generation' | 'build' | 'deploy' | 'optimization' | 'testing';
  syntax: string;
  parameters: {
    name: string;
    type: 'string' | 'number' | 'boolean' | 'array';
    required: boolean;
    description: string;
    default?: any;
  }[];
  examples: string[];
  autoGenerated: boolean;
  sourceCode?: GeneratedCode;
}

export interface CommandExecutionContext {
  workspaceId: string;
  projectPath: string;
  environment: 'development' | 'staging' | 'production';
  userPermissions: string[];
  variables: Record<string, any>;
}

export class MioraCommandBuilder {
  private commands: Map<string, MioraCommand> = new Map();
  
  constructor() {
    this.initializeBaseCommands();
  }

  private initializeBaseCommands() {
    const baseCommands: MioraCommand[] = [
      {
        id: 'generate-component',
        name: '/generate-component',
        description: 'Generate React component from natural language description',
        category: 'generation',
        syntax: '/generate-component <name> <description> [--typescript] [--styled]',
        parameters: [
          { name: 'name', type: 'string', required: true, description: 'Component name' },
          { name: 'description', type: 'string', required: true, description: 'Natural language description' },
          { name: 'typescript', type: 'boolean', required: false, description: 'Use TypeScript', default: true },
          { name: 'styled', type: 'boolean', required: false, description: 'Include styled-components', default: false }
        ],
        examples: [
          '/generate-component UserCard "A card component that displays user information with avatar, name, and actions"',
          '/generate-component DataTable "Interactive table with sorting, filtering, and pagination" --typescript --styled'
        ],
        autoGenerated: false
      },
      {
        id: 'generate-hook',
        name: '/generate-hook',
        description: 'Generate custom React hook',
        category: 'generation',
        syntax: '/generate-hook <name> <description> [--async]',
        parameters: [
          { name: 'name', type: 'string', required: true, description: 'Hook name (without use prefix)' },
          { name: 'description', type: 'string', required: true, description: 'Hook functionality description' },
          { name: 'async', type: 'boolean', required: false, description: 'Support async operations', default: false }
        ],
        examples: [
          '/generate-hook LocalStorage "Hook for managing localStorage with automatic JSON serialization"',
          '/generate-hook ApiData "Hook for fetching and caching API data" --async'
        ],
        autoGenerated: false
      },
      {
        id: 'build-project',
        name: '/build-project',
        description: 'Build the entire project with optimizations',
        category: 'build',
        syntax: '/build-project [--env] [--optimize] [--analyze]',
        parameters: [
          { name: 'env', type: 'string', required: false, description: 'Target environment', default: 'production' },
          { name: 'optimize', type: 'boolean', required: false, description: 'Enable optimizations', default: true },
          { name: 'analyze', type: 'boolean', required: false, description: 'Analyze bundle', default: false }
        ],
        examples: [
          '/build-project',
          '/build-project --env staging --analyze'
        ],
        autoGenerated: false
      },
      {
        id: 'deploy-app',
        name: '/deploy-app',
        description: 'Deploy application to specified environment',
        category: 'deploy',
        syntax: '/deploy-app <environment> [--force] [--rollback]',
        parameters: [
          { name: 'environment', type: 'string', required: true, description: 'Deployment environment' },
          { name: 'force', type: 'boolean', required: false, description: 'Force deployment', default: false },
          { name: 'rollback', type: 'string', required: false, description: 'Rollback to version' }
        ],
        examples: [
          '/deploy-app production',
          '/deploy-app staging --force',
          '/deploy-app production --rollback v1.2.3'
        ],
        autoGenerated: false
      }
    ];

    baseCommands.forEach(cmd => this.commands.set(cmd.id, cmd));
  }

  generateCommandFromCode(code: GeneratedCode, prompt: string): MioraCommand {
    const commandId = `auto-${Date.now()}`;
    const commandName = this.generateCommandName(prompt);
    
    const command: MioraCommand = {
      id: commandId,
      name: commandName,
      description: `Auto-generated command: ${code.description}`,
      category: 'generation',
      syntax: `${commandName} [--deploy] [--test]`,
      parameters: [
        { name: 'deploy', type: 'boolean', required: false, description: 'Deploy after generation', default: false },
        { name: 'test', type: 'boolean', required: false, description: 'Run tests after generation', default: true }
      ],
      examples: [
        `${commandName}`,
        `${commandName} --deploy --test`
      ],
      autoGenerated: true,
      sourceCode: code
    };

    this.commands.set(commandId, command);
    return command;
  }

  private generateCommandName(prompt: string): string {
    // Convert natural language to command name
    const cleaned = prompt
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, '')
      .replace(/\s+/g, '-')
      .substring(0, 30);
    
    return `/generate-${cleaned}`;
  }

  async executeCommand(
    commandId: string, 
    parameters: Record<string, any>,
    context: CommandExecutionContext
  ): Promise<{
    success: boolean;
    output: string;
    artifacts?: {
      files: string[];
      commands: string[];
      deploymentUrl?: string;
    };
  }> {
    const command = this.commands.get(commandId);
    if (!command) {
      throw new Error(`Command not found: ${commandId}`);
    }

    try {
      // Validate parameters
      this.validateParameters(command, parameters);

      // Execute based on command category
      switch (command.category) {
        case 'generation':
          return await this.executeGenerationCommand(command, parameters, context);
        case 'build':
          return await this.executeBuildCommand(command, parameters, context);
        case 'deploy':
          return await this.executeDeployCommand(command, parameters, context);
        case 'optimization':
          return await this.executeOptimizationCommand(command, parameters, context);
        case 'testing':
          return await this.executeTestingCommand(command, parameters, context);
        default:
          throw new Error(`Unsupported command category: ${command.category}`);
      }
    } catch (error) {
      return {
        success: false,
        output: `Command execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  private validateParameters(command: MioraCommand, parameters: Record<string, any>) {
    for (const param of command.parameters) {
      if (param.required && !(param.name in parameters)) {
        throw new Error(`Required parameter missing: ${param.name}`);
      }
      
      if (param.name in parameters) {
        const value = parameters[param.name];
        const expectedType = param.type;
        
        if (expectedType === 'array' && !Array.isArray(value)) {
          throw new Error(`Parameter ${param.name} must be an array`);
        } else if (expectedType !== 'array' && typeof value !== expectedType) {
          throw new Error(`Parameter ${param.name} must be of type ${expectedType}`);
        }
      }
    }
  }

  private async executeGenerationCommand(
    command: MioraCommand,
    parameters: Record<string, any>,
    context: CommandExecutionContext
  ) {
    // Simulate code generation and file creation
    await new Promise(resolve => setTimeout(resolve, 2000));

    const artifacts: {
      files: string[];
      commands: string[];
      deploymentUrl?: string;
    } = {
      files: command.sourceCode?.files.map(f => f.path) || [],
      commands: command.sourceCode?.commands || [],
    };

    if (parameters.deploy) {
      artifacts.deploymentUrl = `https://${context.workspaceId}.miora.dev`;
    }

    return {
      success: true,
      output: `Generated ${artifacts.files.length} files successfully\n${artifacts.files.join('\n')}`,
      artifacts
    };
  }

  private async executeBuildCommand(
    command: MioraCommand,
    parameters: Record<string, any>,
    context: CommandExecutionContext
  ) {
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    return {
      success: true,
      output: `Build completed for environment: ${parameters.env || 'production'}\nBundle size: 245KB\nBuild time: 3.2s`,
      artifacts: {
        files: ['dist/index.html', 'dist/main.js', 'dist/main.css'],
        commands: ['/deploy-app', '/run-tests']
      }
    };
  }

  private async executeDeployCommand(
    command: MioraCommand,
    parameters: Record<string, any>,
    context: CommandExecutionContext
  ) {
    await new Promise(resolve => setTimeout(resolve, 4000));
    
    const deploymentUrl = `https://${context.workspaceId}-${parameters.environment}.miora.dev`;
    
    return {
      success: true,
      output: `Deployment successful to ${parameters.environment}\nURL: ${deploymentUrl}\nVersion: ${Date.now()}`,
      artifacts: {
        files: [],
        commands: ['/run-tests', '/monitor-deployment'],
        deploymentUrl
      }
    };
  }

  private async executeOptimizationCommand(
    command: MioraCommand,
    parameters: Record<string, any>,
    context: CommandExecutionContext
  ) {
    await new Promise(resolve => setTimeout(resolve, 2500));
    
    return {
      success: true,
      output: `Optimization complete\nBundle size reduced by 23%\nLoad time improved by 31%\nPerformance score: 94/100`,
      artifacts: {
        files: ['optimized-bundle.js', 'performance-report.json'],
        commands: ['/build-project', '/deploy-app']
      }
    };
  }

  private async executeTestingCommand(
    command: MioraCommand,
    parameters: Record<string, any>,
    context: CommandExecutionContext
  ) {
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    return {
      success: true,
      output: `Tests completed\nPassed: 47/50\nFailed: 3/50\nCoverage: 87%\nTest time: 1.2s`,
      artifacts: {
        files: ['test-results.json', 'coverage-report.html'],
        commands: ['/fix-failing-tests', '/build-project']
      }
    };
  }

  getAllCommands(): MioraCommand[] {
    return Array.from(this.commands.values());
  }

  getCommand(id: string): MioraCommand | undefined {
    return this.commands.get(id);
  }

  searchCommands(query: string): MioraCommand[] {
    const lowerQuery = query.toLowerCase();
    return Array.from(this.commands.values()).filter(cmd =>
      cmd.name.toLowerCase().includes(lowerQuery) ||
      cmd.description.toLowerCase().includes(lowerQuery)
    );
  }
}

export const mioraCommandBuilder = new MioraCommandBuilder();